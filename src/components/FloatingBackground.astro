---
// src/components/FloatingBackground.astro
interface Props {
  count?: number; // How many dots
}

const { count = 60 } = Astro.props;
---

<canvas id="floating-pattern"></canvas>

<style>
  #floating-pattern {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1; /* Behind everything */
    pointer-events: none; /* Let clicks pass through to website */
    opacity: 0.6;
  }
</style>

<script define:vars={{ count }}>
  // Using a closure to keep the global namespace clean
  (function () {
    const canvas = document.getElementById('floating-pattern');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let particles = [];
    
    // Mouse state
    let mouse = { x: null, y: null, radius: 150 };

    // Current Theme (Context Awareness)
    // Particles will interpolate towards these values
    let targetColor = { r: 100, g: 100, b: 100 }; 
    let particleSpeedModifier = 1;

    // Resize handling
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    
    window.addEventListener('resize', resize);
    resize();

    // Mouse Interaction
    window.addEventListener('mousemove', (e) => {
      mouse.x = e.x;
      mouse.y = e.y;
    });
    
    // Clear mouse influence when leaving window
    window.addEventListener('mouseout', () => {
      mouse.x = null;
      mouse.y = null;
    });

    // --- The Particle Class ---
    class Particle {
      constructor() {
        this.init();
      }

      init() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.size = Math.random() * 2 + 1; // Random size 1px - 3px
        
        // Base velocity (floating effect)
        this.baseVx = (Math.random() - 0.5) * 0.5;
        this.baseVy = (Math.random() - 0.5) * 0.5;
        
        this.vx = this.baseVx;
        this.vy = this.baseVy;
        
        // Current color of this specific particle
        this.r = targetColor.r;
        this.g = targetColor.g;
        this.b = targetColor.b;
      }

      update() {
        // 1. Context Awareness: Smoothly transition color
        // We interpolate current color towards the global targetColor (set by scroll observer)
        this.r += (targetColor.r - this.r) * 0.05;
        this.g += (targetColor.g - this.g) * 0.05;
        this.b += (targetColor.b - this.b) * 0.05;

        // 2. Mouse Interaction (Antigravity)
        if (mouse.x != null) {
          let dx = mouse.x - this.x;
          let dy = mouse.y - this.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < mouse.radius) {
            const forceDirectionX = dx / distance;
            const forceDirectionY = dy / distance;
            const force = (mouse.radius - distance) / mouse.radius;
            
            // Push away
            const directionX = forceDirectionX * force * 3;
            const directionY = forceDirectionY * force * 3;

            this.vx -= directionX;
            this.vy -= directionY;
          }
        }

        // 3. Move
        this.x += this.vx * particleSpeedModifier;
        this.y += this.vy * particleSpeedModifier;

        // 4. Friction (return to base speed)
        // This makes them slow down after being pushed
        this.vx = this.vx * 0.95 + this.baseVx * 0.05;
        this.vy = this.vy * 0.95 + this.baseVy * 0.05;

        // 5. Screen wrapping
        if (this.x < 0) this.x = width;
        if (this.x > width) this.x = 0;
        if (this.y < 0) this.y = height;
        if (this.y > height) this.y = 0;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${Math.floor(this.r)}, ${Math.floor(this.g)}, ${Math.floor(this.b)})`;
        ctx.fill();
      }
    }

    // Initialize Particles
    function initParticles() {
      particles = [];
      for (let i = 0; i < count; i++) {
        particles.push(new Particle());
      }
    }

    // Animation Loop
    function animate() {
      ctx.clearRect(0, 0, width, height);
      particles.forEach(p => {
        p.update();
        p.draw();
      });
      requestAnimationFrame(animate);
    }

    initParticles();
    animate();

    // --- CONTEXT AWARENESS LOGIC ---
    // This part watches your HTML sections to change the particle behavior
    const observerOptions = {
      root: null,
      threshold: 0.2 // Trigger when 20% of section is visible (adjusted for better responsiveness)
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          // Read data attributes from the section
          const colorHex = entry.target.getAttribute('data-particle-color');
          const speed = entry.target.getAttribute('data-particle-speed');

          if (colorHex) {
            // Convert Hex to RGB for smooth interpolation
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(colorHex);
            if (result) {
                targetColor = {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                }
            }
          }
          
          if (speed) {
            particleSpeedModifier = parseFloat(speed);
          }
        }
      });
    }, observerOptions);

    // Start observing all sections with the special attribute
    document.querySelectorAll('[data-particle-color]').forEach(section => {
      observer.observe(section);
    });

  })();
</script>
